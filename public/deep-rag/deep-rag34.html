
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>IndexedDB Text Chunks for Embedding</title>
</head>
<body style="font-family: sans-serif; display: flex; justify-content: center; align-items: center; min-height: 100vh; background-color: #f0f0f0; margin: 0; padding: 20px; box-sizing: border-box;">
    <div class="main-content" style="background-color: #ffffff; padding: 30px; border-radius: 8px; box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1); width: 100%; max-width: 600px;">
        <h1 style="font-size: 1.5rem; font-weight: bold; margin-bottom: 1rem; color: #333; text-align: center;">Text Chunks for Embedding</h1>

        <div class="stats" id="statsArea" style="background-color: #f8f9fa; padding: 10px; border-radius: 4px; margin-bottom: 15px; font-size: 0.9rem; color: #495057;">
            <strong>Database Stats:</strong> Loading...
        </div>

        <div class="model-status" id="modelStatus" style="background-color: #e2f0fb; color: #004085; border: 1px solid #b8daff; padding: 10px; border-radius: 4px; margin-top: 10px; text-align: center; font-size: 0.9rem;">
            Loading embedding model...
        </div>

        <!-- Database Management Section -->
        <div class="db-management-section" style="margin-top: 20px; padding-top: 20px; border-top: 1px solid #eee;">
            <h2>Database Management:</h2>
            <div class="db-select-group" style="display: flex; align-items: center; gap: 10px; margin-bottom: 15px;">
                <label for="dbSelector" style="display: block; margin-bottom: 5px; font-weight: bold; color: #333; font-size: 0.875rem;">Select DB:</label>
                <select id="dbSelector" style="width: 100%; padding: 10px; border: 1px solid #ccc; border-radius: 4px; box-sizing: border-box; font-size: 1rem; flex-grow: 1;"></select>
                <button id="loadDbButton" style="background-color: #007bff; color: white; padding: 10px 15px; border: none; border-radius: 4px; cursor: pointer; font-size: 1rem; width: auto; margin-top: 0;">Load Selected</button>
            </div>
            <div class="input-group" style="margin-bottom: 15px;">
                <label for="newDbNameInput" style="display: block; margin-bottom: 5px; font-weight: bold; color: #333; font-size: 0.875rem;">New DB Name:</label>
                <input type="text" id="newDbNameInput" placeholder="e.g., my_new_rag_db" style="width: 100%; padding: 10px; border: 1px solid #ccc; border-radius: 4px; box-sizing: border-box; font-size: 1rem;">
            </div>
            <div class="db-controls" style="display: flex; gap: 10px; flex-wrap: wrap; margin-top: 10px;">
                <button id="createNewDbButton" style="background-color: #28a745; color: white; padding: 10px 15px; border: none; border-radius: 4px; cursor: pointer; font-size: 1rem; width: 100%; margin-top: 10px; transition: background-color 0.3s ease; flex: 1; min-width: 120px;">Create New DB</button>
                <button id="deleteCurrentDbButton" style="background-color: #dc3545; color: white; padding: 10px 15px; border: none; border-radius: 4px; cursor: pointer; font-size: 1rem; width: 100%; margin-top: 10px; transition: background-color 0.3s ease; flex: 1; min-width: 120px;">Delete Current DB</button>
            </div>
            <p id="currentDbInfo" style="margin-top: 10px; font-size: 0.9rem; color: #555; text-align: center;">Current DB: <span id="currentDbNameDisplay">N/A</span></p>
        </div>


        <!-- Text Entry Section -->
        <div class="input-group" style="margin-bottom: 15px;">
            <label for="textInput" style="display: block; margin-bottom: 5px; font-weight: bold; color: #333; font-size: 0.875rem;">Text Content:</label>
            <textarea id="textInput" placeholder="Enter text to be chunked and embedded..." style="width: 100%; padding: 10px; border: 1px solid #ccc; border-radius: 4px; box-sizing: border-box; font-size: 1rem; min-height: 100px; resize: vertical;"></textarea>
        </div>

        <div class="input-group" style="margin-bottom: 15px;">
            <label for="sourceInput" style="display: block; margin-bottom: 5px; font-weight: bold; color: #333; font-size: 0.875rem;">Source (optional):</label>
            <input type="text" id="sourceInput" placeholder="e.g., document.pdf, chapter 1, etc." style="width: 100%; padding: 10px; border: 1px solid #ccc; border-radius: 4px; box-sizing: border-box; font-size: 1rem;">
        </div>

        <div class="input-group" style="margin-bottom: 15px;">
            <label for="chunkSizeInput" style="display: block; margin-bottom: 5px; font-weight: bold; color: #333; font-size: 0.875rem;">Chunk Size (characters):</label>
            <input type="number" id="chunkSizeInput" value="500" min="100" max="2000" placeholder="500" style="width: 100%; padding: 10px; border: 1px solid #ccc; border-radius: 4px; box-sizing: border-box; font-size: 1rem;">
        </div>

        <div class="input-group" style="margin-bottom: 15px;">
            <label style="display: block; margin-bottom: 5px; font-weight: bold; color: #333; font-size: 0.875rem;">
                <input type="checkbox" id="autoChunkCheckbox" checked style="margin-right: 8px;">
                Auto-chunk large text (splits text longer than chunk size)
            </label>
        </div>

        <button id="saveChunkButton" style="background-color: #4CAF50; color: white; padding: 10px 15px; border: none; border-radius: 4px; cursor: pointer; font-size: 1rem; width: 100%; margin-top: 10px; transition: background-color 0.3s ease;">Process & Add Text</button>
        <button id="generateEmbeddingsButton" style="background-color: #3b82f6; color: white; padding: 10px 15px; border: none; border-radius: 4px; cursor: pointer; font-size: 1rem; width: 100%; margin-top: 10px; transition: background-color 0.3s ease;">Generate Embeddings</button>

        <div id="messageBox" style="background-color: #fff3cd; color: #664d03; border: 1px solid #ffecb5; padding: 10px; border-radius: 4px; margin-top: 10px; display: none;"></div>

        <!-- Moved this outside the 'stored-items' div -->
        <div class="show-chunks-group" style="display: flex; align-items: center; margin-top: 20px; margin-bottom: 10px; font-weight: bold; color: #333;">
            <input type="checkbox" id="showChunksCheckbox" checked style="width: auto; margin-right: 10px;">
            <label for="showChunksCheckbox">Show Stored Chunks</label>
        </div>

        <div class="stored-items" style="margin-top: 20px; padding-top: 20px; border-top: 1px solid #eee;">
            <h2 style="margin-bottom: 10px; color: #333; font-size: 1.25rem; font-weight: 600;">Stored Text Chunks:</h2>
            <div id="displayArea">
                <p>No text chunks stored yet.</p>
            </div>
        </div>

        <!-- Data Input/Output Section -->
        <div class="data-io-section" style="margin-top: 20px; padding-top: 20px; border-top: 1px solid #eee;">
            <h2>Data Import/Export:</h2>
            <div class="csv-input-group" style="display: flex; align-items: center; gap: 10px; margin-bottom: 15px;">
                <label for="csvFileInput" style="display: block; margin-bottom: 5px; font-weight: bold; color: #333; font-size: 0.875rem;">Upload CSV:</label>
                <input type="file" id="csvFileInput" accept=".csv" style="width: 100%; padding: 10px; border: 1px solid #ccc; border-radius: 4px; box-sizing: border-box; font-size: 1rem; flex-grow: 1; padding: 8px;">
                <button id="loadCsvButton" style="background-color: #4CAF50; color: white; padding: 10px 15px; border: none; border-radius: 4px; cursor: pointer; font-size: 1rem; width: auto; margin-top: 0; transition: background-color 0.3s ease;">Load CSV</button>
            </div>
            <button id="downloadCsvButton" style="background-color: #17a2b8; color: white; padding: 10px 15px; border: none; border-radius: 4px; cursor: pointer; font-size: 1rem; width: 100%; margin-top: 10px; transition: background-color 0.3s ease; margin-bottom: 10px;">Download Data as CSV</button>
        </div>


        <!-- Query Section -->
        <div class="query-section" style="margin-top: 20px; padding-top: 20px; border-top: 1px solid #eee;">
            <h2>Query & Retrieve:</h2>
            <div class="input-group" style="margin-bottom: 15px;">
                <label for="queryInput" style="display: block; margin-bottom: 5px; font-weight: bold; color: #333; font-size: 0.875rem;">Your Query:</label>
                <textarea id="queryInput" placeholder="Enter your question here..." style="width: 100%; padding: 10px; border: 1px solid #ccc; border-radius: 4px; box-sizing: border-box; font-size: 1rem; min-height: 150px; resize: vertical; background-color: #f9f9f9;"></textarea>
            </div>
            <div class="input-group" style="margin-bottom: 15px;">
                <label for="topResponsesInput" style="display: block; margin-bottom: 5px; font-weight: bold; color: #333; font-size: 0.875rem;">Number of Top Responses:</label>
                <input type="number" id="topResponsesInput" value="5" min="1" max="20" style="width: 100%; padding: 10px; border: 1px solid #ccc; border-radius: 4px; box-sizing: border-box; font-size: 1rem;">
            </div>
            <button id="searchChunksButton" style="background-color: #007bff; color: white; padding: 10px 15px; border: none; border-radius: 4px; cursor: pointer; font-size: 1rem; width: 100%; margin-top: 10px; transition: background-color 0.3s ease;">Search Chunks</button>
            <div id="searchResultsArea" style="margin-top: 15px; background-color: #eff6ff; padding: 15px; border-radius: 4px; border: 1px solid #bfdbfe;">
                <p>Search results will appear here.</p>
            </div>

            <!-- LLM Prompt Section (Plain Text) -->
            <div class="input-group" id="llmPromptGroup" style="display: none; margin-bottom: 15px;">
                <label for="llmPromptOutput" style="display: block; margin-bottom: 5px; font-weight: bold; color: #333; font-size: 0.875rem;">LLM Prompt (Plain Text):</label>
                <textarea id="llmPromptOutput" readonly style="width: 100%; min-height: 150px; padding: 10px; border: 1px solid #ccc; border-radius: 4px; box-sizing: border-box; font-size: 0.9rem; margin-top: 10px; resize: vertical; background-color: #f9f9f9;"></textarea>
                <button id="copyPromptButton" style="background-color: #6c757d; color: white; padding: 10px 15px; border: none; border-radius: 4px; cursor: pointer; font-size: 1rem; width: 100%; margin-top: 5px; transition: background-color 0.3s ease;">Copy Prompt to Clipboard</button>
            </div>

            <!-- New LLM Prompt Section (JSON Format) -->
            <div class="input-group" id="llmJsonPromptGroup" style="display: none; margin-top: 20px; margin-bottom: 15px;">
                <label for="llmJsonPromptOutput" style="display: block; margin-bottom: 5px; font-weight: bold; color: #333; font-size: 0.875rem;">LLM Prompt (JSON Format):</label>
                <textarea id="llmJsonPromptOutput" readonly style="width: 100%; min-height: 150px; padding: 10px; border: 1px solid #ccc; border-radius: 4px; box-sizing: border-box; font-size: 0.9rem; margin-top: 10px; resize: vertical; background-color: #f9f9f9;"></textarea>
                <button id="copyJsonPromptButton" style="background-color: #6c757d; color: white; padding: 10px 15px; border: none; border-radius: 4px; cursor: pointer; font-size: 1rem; width: 100%; margin-top: 5px; transition: background-color 0.3s ease;">Copy JSON Prompt to Clipboard</button>
            </div>
        </div>
    </div>

    <!-- Chunk Content Modal -->
    <div id="chunkModal" style="position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0, 0, 0, 0.6); display: none; justify-content: center; align-items: center; z-index: 1000;">
        <div class="modal-content" style="background-color: #ffffff; padding: 25px; border-radius: 8px; box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3); width: 90%; max-width: 700px; max-height: 80vh; overflow-y: auto; position: relative;">
            <div class="modal-header" style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px; border-bottom: 1px solid #eee; padding-bottom: 10px;">
                <h3 id="modalChunkTitle" style="margin: 0; font-size: 1.2rem; color: #333;">Chunk Content</h3>
                <button id="modalCloseButton" style="background: none; border: none; font-size: 1.5rem; cursor: pointer; color: #666; padding: 0;">&times;</button>
            </div>
            <div class="modal-body">
                <pre id="modalChunkContent" style="white-space: pre-wrap; word-wrap: break-word; font-family: sans-serif; font-size: 1rem; line-height: 1.5; color: #444; background-color: #f8f8f8; padding: 10px; border-radius: 4px; border: 1px solid #ddd;"></pre>
            </div>
        </div>
    </div>

    <script type="module">
        // Import the pipeline function from Transformer.js
        import { pipeline } from 'https://cdn.jsdelivr.net/npm/@huggingface/transformers@3.5.1';

        // Get references to HTML elements
        const textInput = document.getElementById('textInput');
        const sourceInput = document.getElementById('sourceInput');
        const saveChunkButton = document.getElementById('saveChunkButton');
        const displayArea = document.getElementById('displayArea');
        const messageBox = document.getElementById('messageBox');
        const statsArea = document.getElementById('statsArea');
        const modelStatus = document.getElementById('modelStatus');
        const generateEmbeddingsButton = document.getElementById('generateEmbeddingsButton');
        const queryInput = document.getElementById('queryInput');
        const topResponsesInput = document.getElementById('topResponsesInput');
        const searchChunksButton = document.getElementById('searchChunksButton');
        const searchResultsArea = document.getElementById('searchResultsArea');
        const llmPromptOutput = document.getElementById('llmPromptOutput');
        const llmPromptGroup = document.getElementById('llmPromptGroup');
        const copyPromptButton = document.getElementById('copyPromptButton');
        const llmJsonPromptOutput = document.getElementById('llmJsonPromptOutput');
        const llmJsonPromptGroup = document.getElementById('llmJsonPromptGroup');
        const copyJsonPromptButton = document.getElementById('copyJsonPromptButton');
        const csvFileInput = document.getElementById('csvFileInput');
        const loadCsvButton = document.getElementById('loadCsvButton');
        const downloadCsvButton = document.getElementById('downloadCsvButton');

        // New DB management elements
        const dbSelector = document.getElementById('dbSelector');
        // FIX: Removed 'document = ' from this line as it was attempting to reassign the global document object.
        const loadDbButton = document.getElementById('loadDbButton');
        const newDbNameInput = document.getElementById('newDbNameInput');
        const createNewDbButton = document.getElementById('createNewDbButton');
        const deleteCurrentDbButton = document.getElementById('deleteCurrentDbButton');
        const currentDbNameDisplay = document.getElementById('currentDbNameDisplay');

        // New show chunks checkbox
        const showChunksCheckbox = document.getElementById('showChunksCheckbox');
        const storedItemsContainer = document.querySelector('.stored-items'); // Get the container

        // Modal elements
        const chunkModal = document.getElementById('chunkModal');
        const modalChunkTitle = document.getElementById('modalChunkTitle');
        const modalChunkContent = document.getElementById('modalChunkContent');
        const modalCloseButton = document.getElementById('modalCloseButton');


        // IndexedDB variables
        const DB_LIST_KEY = 'rag_db_list'; // localStorage key to store list of DB names
        const LAST_USED_DB_KEY = 'rag_last_used_db'; // localStorage key for last used DB
        const DB_VERSION = 16; // Increment DB version for new functionality
        const STORE_NAME = 'textChunks';
        const COUNTER_KEY = '__nextChunkIdCounter';
        let db;
        let currentDBName; // Variable to hold the name of the currently active database

        // Transformer.js model variables
        let embeddingPipeline = null;
        const embeddingModelName = 'Xenova/all-MiniLM-L6-v2'; // Still using Xenova model name convention

        // Function to display messages to the user
        function showMessage(message, type = 'info') {
            messageBox.textContent = message;
            messageBox.style.display = 'block';
            switch (type) {
                case 'success':
                    messageBox.style.backgroundColor = '#d4edda';
                    messageBox.style.color = '#155724';
                    messageBox.style.borderColor = '#c3e6cb';
                    break;
                case 'error':
                    messageBox.style.backgroundColor = '#f8d7da';
                    messageBox.style.color = '#721c24';
                    messageBox.style.borderColor = '#f5c6cb';
                    break;
                case 'info':
                default:
                    messageBox.style.backgroundColor = '#fff3cd';
                    messageBox.style.color = '#664d03';
                    messageBox.style.borderColor = '#ffecb5';
                    break;
            }
            setTimeout(() => {
                messageBox.style.display = 'none';
            }, 3000);
        }

        // Function to update stats display
        async function updateStats() {
            try {
                if (!db) {
                    statsArea.innerHTML = `<strong>Database Stats:</strong> No database loaded.`;
                    return;
                }

                const transaction = db.transaction([STORE_NAME], 'readonly');
                const objectStore = transaction.objectStore(STORE_NAME);
                const allItemsRequest = objectStore.getAll();

                allItemsRequest.onsuccess = (event) => {
                    const allItems = event.target.result;
                    const chunks = allItems.filter(item => item.id !== COUNTER_KEY);
                    const totalChars = chunks.reduce((sum, chunk) => sum + (chunk.content?.length || 0), 0);
                    const embeddedChunks = chunks.filter(chunk => chunk.isEmbedded).length;

                    statsArea.innerHTML = `
                        <strong>Database Stats:</strong>
                        ${chunks.length} text chunks |
                        ${totalChars} total characters |
                        Average: ${chunks.length > 0 ? Math.round(totalChars / chunks.length) : 0} chars per chunk |
                        Embedded: ${embeddedChunks} / ${chunks.length}
                    `;
                };
            } catch (error) {
                console.error("Error updating stats:", error);
            }
        }

        /**
         * Opens an IndexedDB database.
         * @param {string} dbName The name of the database to open.
         * @returns {Promise<IDBDatabase>} A promise that resolves with the opened database.
         */
        function openDB(dbName) {
            return new Promise((resolve, reject) => {
                if (db) { // Close existing DB connection if any
                    db.close();
                    db = null;
                }
                currentDBName = dbName;
                localStorage.setItem(LAST_USED_DB_KEY, dbName);
                currentDbNameDisplay.textContent = dbName;

                console.log(`Opening IndexedDB: ${dbName} (Version: ${DB_VERSION})`);
                const request = indexedDB.open(dbName, DB_VERSION);

                request.onerror = (event) => {
                    console.error("IndexedDB error:", event.target.error);
                    showMessage(`Error opening database '${dbName}': ${event.target.error?.message}`, 'error');
                    reject('Database error: ' + event.target.error?.message);
                };

                request.onupgradeneeded = (event) => {
                    db = event.target.result;
                    console.log(`Database upgrade needed for '${dbName}'. Old version: ${event.oldVersion}`);

                    let objectStore;
                    if (!db.objectStoreNames.contains(STORE_NAME)) {
                        objectStore = db.createObjectStore(STORE_NAME, { keyPath: 'id' });
                        console.log(`Object store '${STORE_NAME}' created.`);

                        // Initialize the counter if new store
                        objectStore.add({ id: COUNTER_KEY, value: 1 });
                    } else {
                        // If store already exists, get it for modifications
                        objectStore = event.target.transaction.objectStore(STORE_NAME);
                    }

                    // Create/update indexes for efficient querying
                    if (!objectStore.indexNames.contains('timestamp')) {
                        objectStore.createIndex('timestamp', 'timestamp', { unique: false });
                    }
                    if (!objectStore.indexNames.contains('source')) {
                        objectStore.createIndex('source', 'source', { unique: false });
                    }
                    if (!objectStore.indexNames.contains('wordCount')) {
                        objectStore.createIndex('wordCount', 'wordCount', { unique: false });
                    }
                    if (!objectStore.indexNames.contains('isEmbedded')) {
                        objectStore.createIndex('isEmbedded', 'isEmbedded', { unique: false });
                    }
                    if (!objectStore.indexNames.contains('embeddingModel')) {
                        objectStore.createIndex('embeddingModel', 'embeddingModel', { unique: false });
                    }

                    console.log(`Initialized/updated indexes for '${dbName}'.`);
                };

                request.onsuccess = (event) => {
                    db = event.target.result;
                    console.log(`Database '${dbName}' opened successfully.`);
                    showMessage(`Database '${dbName}' loaded.`, 'success');
                    resolve(db);
                };
            });
        }

        /**
         * Helper function to split text into chunks based on size.
         * Enforces that chunks are at least `chunkSize` long, unless it's the very last segment of text.
         * Attempts to respect sentence boundaries if they fall within a reasonable window.
         * @param {string} text The text to split.
         * @param {number} chunkSize The maximum size of each chunk.
         * @param {string} source The source to assign to the chunks.
         * @returns {Array<Object>} An array of chunk objects.
         */
        function splitTextIntoChunks(text, chunkSize, source) {
            console.log(`[splitTextIntoChunks] Starting chunking for text length: ${text.length}, desired chunkSize: ${chunkSize}`);
            const chunks = [];
            let currentStartIndex = 0;
            let chunkNumber = 1;

            while (currentStartIndex < text.length) {
                let idealEndIndex = Math.min(currentStartIndex + chunkSize, text.length);
                let actualEndIndex = idealEndIndex; // This will be the end index for the current chunk
                let chunkContent;

                const remainingTextLength = text.length - currentStartIndex;

                // Rule 1: If this is the very last potential chunk and it's shorter than chunkSize, just take it.
                if (remainingTextLength <= chunkSize) {
                    chunkContent = text.substring(currentStartIndex, text.length);
                    actualEndIndex = text.length;
                    console.log(`[Chunk ${chunkNumber}] This is the last portion of text (length: ${chunkContent.length}). Adding as is.`);
                } else {
                    // Rule 2: Try to find a sentence boundary within a 'look-back' window from idealEndIndex.
                    // This window ensures the chunk remains close to `chunkSize`.
                    // Don't cut if it makes the chunk less than 80% of chunkSize.
                    const MIN_PERCENT_FOR_SENTENCE_CUT = 0.8; 
                    const searchStartForSentence = currentStartIndex + Math.floor(chunkSize * MIN_PERCENT_FOR_SENTENCE_CUT);
                    
                    let sentenceBreakFound = false;
                    // Search for a sentence ending from `idealEndIndex - 1` backwards to `searchStartForSentence`
                    for (let i = idealEndIndex - 1; i >= searchStartForSentence; i--) {
                        // Ensure we don't go before the start of the current segment
                        if (i >= currentStartIndex && (text[i] === '.' || text[i] === '?' || text[i] === '!')) {
                            actualEndIndex = i + 1; // Include the punctuation
                            sentenceBreakFound = true;
                            console.log(`[Chunk ${chunkNumber}] Found sentence break at index ${i}. Chunk will end at ${actualEndIndex}.`);
                            break;
                        }
                    }

                    if (!sentenceBreakFound) {
                        // If no good sentence break found in the window, or it would make the chunk too small,
                        // stick to the ideal chunkSize cut.
                        actualEndIndex = idealEndIndex;
                        console.log(`[Chunk ${chunkNumber}] No suitable sentence break found in window. Cutting strictly at ideal chunkSize boundary.`);
                    }

                    chunkContent = text.substring(currentStartIndex, actualEndIndex);

                    // Final check for non-last chunks: if the *chosen* `chunkContent` is still too small
                    // AND there's more text *after* it, it means the sentence break logic cut too early.
                    // In this case, revert to the strict `chunkSize` cut to uphold the user's main rule.
                    if (actualEndIndex - currentStartIndex < chunkSize * MIN_PERCENT_FOR_SENTENCE_CUT && (text.length - actualEndIndex) > 0) {
                        console.log(`[Chunk ${chunkNumber}] Adjusted chunk (len: ${actualEndIndex - currentStartIndex}) is < ${MIN_PERCENT_FOR_SENTENCE_CUT * 100}% of chunkSize (${chunkSize}). Reverting to strict chunkSize.`);
                        actualEndIndex = idealEndIndex;
                        chunkContent = text.substring(currentStartIndex, actualEndIndex);
                    }
                }
                
                chunks.push({
                    content: chunkContent.trim(),
                    source: `${source} (part ${chunkNumber})`
                });
                console.log(`[Chunk ${chunkNumber}] Final Added (len: ${chunkContent.length}) from index ${currentStartIndex} to ${actualEndIndex}. Source: "${chunks[chunks.length-1].source}"`);
                currentStartIndex = actualEndIndex;
                chunkNumber++;
            }

            console.log(`[splitTextIntoChunks] Finished chunking. Total chunks created: ${chunks.length}`);
            return chunks;
        }


        // Function to save a new text chunk (can be called by manual input or CSV)
        // Now returns a Promise to indicate completion of its internal transaction
        async function saveNewChunk(content, source = 'Unknown') {
            console.log("DEBUG: saveNewChunk function is being executed."); // New log
            return new Promise((resolve, reject) => { // Removed 'async' from here, promise constructor is synchronous
                console.log("Adding new text chunk...");
                if (content === "") {
                    resolve(); // Resolve to allow bulk import to continue
                    return;
                }

                try {
                    if (!db) {
                        reject("No database loaded. Please create or load a database first.");
                        return;
                    }

                    const transaction = db.transaction([STORE_NAME], 'readwrite');
                    const objectStore = transaction.objectStore(STORE_NAME);

                    const counterRequest = objectStore.get(COUNTER_KEY);
                    counterRequest.onsuccess = () => {
                        let nextIdValue = 1;
                        if (counterRequest.result) {
                            nextIdValue = counterRequest.result.value;
                        }

                        const chunkId = 'chunk_' + nextIdValue;

                        const textChunk = {
                            id: chunkId,
                            content: content,
                            source: source,
                            timestamp: new Date().toISOString(),
                            wordCount: content.split(/\s+/).length,
                            charCount: content.length,
                            embedding: null,
                            embeddingModel: null,
                            isEmbedded: false
                        };

                        console.log(`Saving text chunk: ID="${chunkId}"`);
                        objectStore.put(textChunk);
                        objectStore.put({ id: COUNTER_KEY, value: nextIdValue + 1 });

                        transaction.oncomplete = () => {
                            console.log("Text chunk saved successfully.");
                            resolve();
                        };

                        transaction.onerror = (event) => {
                            console.error("Transaction error:", event.target.error);
                            reject(event.target.error);
                        };
                    };
                    counterRequest.onerror = (event) => {
                        console.error("Counter request error:", event.target.error);
                        reject(event.target.error);
                    };

                } catch (error) {
                    console.error("Failed to add text chunk:", error);
                    reject(error);
                }
            });
        }
        console.log("DEBUG: saveNewChunk function definition completed."); // New log after definition


        // Manual text input handler
        document.getElementById('saveChunkButton').addEventListener('click', async () => {
            const content = textInput.value.trim();
            const source = sourceInput.value.trim() || 'Manual Input';
            const chunkSize = parseInt(document.getElementById('chunkSizeInput').value, 10);
            const autoChunk = document.getElementById('autoChunkCheckbox').checked;

            if (content === "") {
                showMessage("Text content cannot be empty.", 'info');
                return;
            }

            let chunksToProcess = [];
            if (autoChunk && content.length > chunkSize) {
                console.log(`Text length (${content.length}) exceeds chunk size (${chunkSize}). Auto-chunking...`);
                chunksToProcess = splitTextIntoChunks(content, chunkSize, source);
            } else {
                // If not auto-chunking or content is shorter than chunkSize, treat as a single chunk
                chunksToProcess.push({ content: content, source: source });
            }

            if (chunksToProcess.length === 0) {
                showMessage("No valid chunks to process after chunking rules applied.", 'error');
                return;
            }

            // Disable buttons during processing
            saveChunkButton.disabled = true;
            generateEmbeddingsButton.disabled = true;
            loadCsvButton.disabled = true;
            downloadCsvButton.disabled = true;

            showMessage(`Processing ${chunksToProcess.length} chunk(s)...`);

            let successfulAdds = 0;
            let failedAdds = 0;

            try {
                if (!db) {
                    showMessage("No database loaded. Please create or load a database first.", 'error');
                    return;
                }
                
                // Use a single transaction for all insertions
                const transaction = db.transaction([STORE_NAME], 'readwrite');
                const objectStore = transaction.objectStore(STORE_NAME);

                // Fetch the current counter once
                const counterRequest = objectStore.get(COUNTER_KEY);
                counterRequest.onsuccess = () => {
                    let nextIdValue = counterRequest.result ? counterRequest.result.value : 1;

                    chunksToProcess.forEach(chunkData => {
                        const chunkId = 'chunk_' + nextIdValue;
                        const textChunk = {
                            id: chunkId,
                            content: chunkData.content,
                            source: chunkData.source,
                            timestamp: new Date().toISOString(),
                            wordCount: chunkData.content.split(/\s+/).length,
                            charCount: chunkData.content.length,
                            embedding: null,
                            embeddingModel: null,
                            isEmbedded: false
                        };
                        try {
                            objectStore.put(textChunk);
                            nextIdValue++;
                            successfulAdds++;
                            console.log(`DEBUG: Added chunk ${chunkId} to transaction.`);
                        } catch (e) {
                            console.error(`DEBUG: Failed to add chunk ${chunkId} to transaction:`, e);
                            failedAdds++;
                        }
                    });

                    // Update the counter after all chunks are processed in this batch
                    objectStore.put({ id: COUNTER_KEY, value: nextIdValue });

                    transaction.oncomplete = () => {
                        showMessage(`Batch processing complete. Successfully added: ${successfulAdds} chunks. Failed: ${failedAdds}.`, 'success');
                        textInput.value = ''; // Clear manual input after saving
                        sourceInput.value = '';
                        displayChunks();
                        updateStats();
                        // Re-enable buttons
                        saveChunkButton.disabled = false;
                        generateEmbeddingsButton.disabled = false;
                        loadCsvButton.disabled = false;
                        downloadCsvButton.disabled = false;
                    };

                    transaction.onerror = (event) => {
                        console.error("DEBUG: Transaction error during manual input batch:", event.target.error);
                        showMessage(`Error during batch processing: ${event.target.error?.message}. Added: ${successfulAdds}, Failed: ${failedAdds}.`, 'error');
                        // Re-enable buttons
                        saveChunkButton.disabled = false;
                        generateEmbeddingsButton.disabled = false;
                        loadCsvButton.disabled = false;
                        downloadCsvButton.disabled = false;
                    };
                };

                counterRequest.onerror = (event) => {
                    console.error("DEBUG: Counter request error during manual input process:", event.target.error);
                    showMessage(`Error retrieving chunk counter: ${event.target.error?.message}`, 'error');
                    // Re-enable buttons
                    saveChunkButton.disabled = false;
                    generateEmbeddingsButton.disabled = false;
                    loadCsvButton.disabled = false;
                    downloadCsvButton.disabled = false;
                };

            } catch (error) {
                console.error("DEBUG: Unexpected error during manual input processing:", error);
                showMessage(`Unexpected error during manual input processing: ${error.message || error}`, 'error');
                // Re-enable buttons
                saveChunkButton.disabled = false;
                generateEmbeddingsButton.disabled = false;
                loadCsvButton.disabled = false;
                downloadCsvButton.disabled = false;
            }
        });


        // Function to delete a chunk by its ID
        async function deleteChunk(id) {
            console.log(`DEBUG: deleteChunk(${id}) called.`);
            try {
                if (!db) {
                    showMessage("No database loaded to delete from.", 'info');
                    console.warn(`DEBUG: Delete failed: No DB loaded for chunk ${id}`);
                    return;
                }

                const transaction = db.transaction([STORE_NAME], 'readwrite');
                const objectStore = transaction.objectStore(STORE_NAME);
                console.log(`DEBUG: Initiating IndexedDB delete request for ID: ${id}`);
                const request = objectStore.delete(id);

                request.onsuccess = () => {
                    console.log(`DEBUG: IndexedDB delete operation for chunk '${id}' succeeded.`);
                    showMessage("Text chunk deleted successfully!", 'success');
                    // Re-render the display area to reflect changes
                    console.log(`DEBUG: Calling displayChunks() and updateStats() after successful delete.`);
                    displayChunks();
                    // Update the statistics
                    updateStats();
                };

                request.onerror = (event) => {
                    console.error(`DEBUG: Error deleting chunk '${id}' in IndexedDB:`, event.target.error);
                    showMessage("Error deleting chunk: " + event.target.error?.message, 'error');
                };

                // Ensure the transaction completes. This is useful for catching overall transaction errors.
                transaction.oncomplete = () => {
                    console.log(`DEBUG: IndexedDB transaction for deleting chunk ${id} completed.`);
                };
                transaction.onabort = () => {
                    console.log(`DEBUG: IndexedDB transaction for deleting chunk ${id} aborted.`);
                    showMessage(`Deletion of chunk ${id} aborted.`, 'error');
                };

            } catch (error) {
                console.error(`DEBUG: Failed to initiate delete operation for chunk '${id}':`, error);
                showMessage("Failed to delete chunk due to an unexpected error.", 'error');
            }
        }

        // Function to display all text chunks
        async function displayChunks() {
            console.log(`DEBUG: displayChunks() called. showChunksCheckbox.checked: ${showChunksCheckbox.checked}`);
            displayArea.innerHTML = ''; // Clear current display

            if (!showChunksCheckbox.checked) {
                storedItemsContainer.style.display = 'none'; // Hide the entire section
                displayArea.innerHTML = '<p>Chunk display is hidden. Check "Show Stored Chunks" to view.</p>'; // Add message inside displayArea
                console.log("DEBUG: Chunk display is hidden. Hiding container and showing message.");
                return;
            }

            storedItemsContainer.style.display = 'block'; // Show the container
            console.log("DEBUG: Chunk display is visible. Populating chunks...");

            try {
                if (!db) {
                    displayArea.innerHTML = '<p>No database loaded. Please create or load one.</p>';
                    console.warn("DEBUG: displayChunks failed: No DB loaded.");
                    return;
                }

                const transaction = db.transaction([STORE_NAME], 'readonly');
                const objectStore = transaction.objectStore(STORE_NAME);
                const allItemsRequest = objectStore.getAll();

                allItemsRequest.onsuccess = (event) => {
                    const allItems = event.target.result;
                    const chunks = allItems.filter(item => item.id !== COUNTER_KEY);
                    console.log(`DEBUG: Fetched ${chunks.length} chunks for display (after filtering counter).`);

                    if (chunks.length > 0) {
                        chunks.sort((a, b) => new Date(b.timestamp) - new Date(a.timestamp)); // Sort by timestamp (newest first)

                        chunks.forEach(chunk => {
                            const div = document.createElement('div');
                            div.style.cssText = 'background-color: #e9ecef; padding: 15px; border-radius: 4px; margin-bottom: 12px; word-wrap: break-word; border-left: 4px solid #4CAF50;'; /* inline styles */
                            div.setAttribute('data-chunk-id', chunk.id); // Add data attribute for easier identification

                            const chunkNumber = chunk.id.split('_')[1];
                            const date = new Date(chunk.timestamp).toLocaleString();

                            const deleteButton = document.createElement('button');
                            deleteButton.style.cssText = 'background-color: #dc3545; color: white; padding: 5px 10px; border: none; border-radius: 4px; cursor: pointer; font-size: 0.8rem; width: auto; margin-top: 0; margin-left: 10px;'; /* inline styles */
                            deleteButton.textContent = 'Delete';
                            deleteButton.addEventListener('click', () => deleteChunk(chunk.id)); // Attach event listener here

                            const viewButton = document.createElement('button'); // New View Button
                            viewButton.style.cssText = 'background-color: #17a2b8; color: white; padding: 5px 10px; border: none; border-radius: 4px; cursor: pointer; font-size: 0.8rem; width: auto; margin-top: 0; margin-left: 5px;'; /* inline styles */
                            viewButton.textContent = 'View';
                            viewButton.addEventListener('click', () => showChunkModal(`Chunk #${chunkNumber} (Source: ${chunk.source})`, chunk.content));


                            const itemHeader = document.createElement('div');
                            itemHeader.style.cssText = 'display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px; font-weight: bold; color: #333;'; /* inline styles */
                            const spanChunkNumber = document.createElement('span');
                            spanChunkNumber.textContent = `Chunk #${chunkNumber}`;
                            itemHeader.appendChild(spanChunkNumber);
                            
                            // Create a container for buttons to group them visually
                            const buttonContainer = document.createElement('div');
                            buttonContainer.appendChild(viewButton); // View button first
                            buttonContainer.appendChild(deleteButton); // Delete button second
                            itemHeader.appendChild(buttonContainer);


                            div.appendChild(itemHeader);

                            const itemMetadata = document.createElement('div');
                            itemMetadata.style.cssText = 'font-size: 0.8rem; color: #666; margin-bottom: 8px;'; /* inline styles */
                            itemMetadata.innerHTML = `
                                Source: ${chunk.source} |
                                ${chunk.wordCount} words, ${chunk.charCount} chars |
                                Added: ${date} |
                                Embedded: ${chunk.isEmbedded ? '✅' : '❌'}
                            `;
                            div.appendChild(itemMetadata);

                            const itemContent = document.createElement('div');
                            itemContent.style.cssText = 'line-height: 1.4; color: #444;'; /* inline styles */
                            itemContent.textContent = chunk.content.length > 200 ? chunk.content.substring(0, 200) + '...' : chunk.content;
                            div.appendChild(itemContent);
                            
                            displayArea.appendChild(div);
                        });
                        console.log("DEBUG: All chunks appended to displayArea.");
                    } else {
                        displayArea.innerHTML = '<p>No text chunks stored yet.</p>';
                        console.log("DEBUG: No chunks found, displaying empty message.");
                    }
                };

                allItemsRequest.onerror = (event) => {
                    console.error("DEBUG: Error retrieving chunks in displayChunks:", event.target.error);
                    showMessage("Error retrieving chunks from database.", 'error');
                };

            } catch (error) {
                console.error("DEBUG: Failed to execute displayChunks:", error);
                showMessage("Failed to display chunks due to an unexpected error during retrieval.", 'error');
            }
        }

        // --- Modal Functions ---
        function showChunkModal(title, content) {
            modalChunkTitle.textContent = title;
            modalChunkContent.textContent = content;
            chunkModal.style.display = 'flex'; // Use flex to center
        }

        function closeChunkModal() {
            chunkModal.style.display = 'none';
            modalChunkTitle.textContent = '';
            modalChunkContent.textContent = '';
        }

        modalCloseButton.addEventListener('click', closeChunkModal);
        // Also close modal if clicking outside the content
        chunkModal.addEventListener('click', (event) => {
            if (event.target === chunkModal) {
                closeChunkModal();
            }
        });


        // --- Transformer.js Embedding Functions ---

        // Initialize the embedding model with progress updates
        async function initializeModel() {
            saveChunkButton.disabled = true;
            generateEmbeddingsButton.disabled = true;
            searchChunksButton.disabled = true;
            loadCsvButton.disabled = true;
            downloadCsvButton.disabled = true;
            createNewDbButton.disabled = true;
            deleteCurrentDbButton.disabled = true;
            loadDbButton.disabled = true;

            modelStatus.textContent = `Connecting to model resources for "${embeddingModelName}"...`; // Added this line

            // Progress callback function
            const progress_callback = (data) => {
                let statusMessage = '';
                if (data.status === 'download') {
                    const loadedMB = (data.loaded / (1024 * 1024)).toFixed(2);
                    const totalMB = (data.total / (1024 * 1024)).toFixed(2);
                    const percentage = data.progress ? data.progress.toFixed(2) : '0.00';
                    const fileName = data.file ? data.file.split('/').pop() : 'model file'; // Extract filename or use generic
                    statusMessage = `Downloading ${fileName} (${percentage}%) - ${loadedMB}MB / ${totalMB}MB`;
                    console.log(`DEBUG: Model Download Progress: ${statusMessage}`); // Added debug log
                } else if (data.status === 'progress') {
                     // This 'progress' status is for the overall loading, after download
                    const percentage = data.progress ? data.progress.toFixed(2) : '0.00';
                    statusMessage = `Processing model files: ${percentage}%`;
                    console.log(`DEBUG: Model Processing Progress: ${statusMessage}`); // Added debug log
                } else if (data.status === 'ready') {
                    statusMessage = `Model ready!`;
                    console.log(`DEBUG: Model Status: ${statusMessage}`); // Added debug log
                } else { // Fallback for other statuses, should not typically occur if statuses are 'download', 'progress', 'ready'
                    statusMessage = `Initializing embedding model: ${embeddingModelName}... (Status: ${data.status})`;
                    console.log(`DEBUG: Model Initializing: ${statusMessage} (Status: ${data.status})`); // Added debug log
                }
                modelStatus.textContent = statusMessage;
            };

            try {
                // Pass the progress_callback to the pipeline function
                embeddingPipeline = await pipeline('feature-extraction', embeddingModelName, { progress_callback });
                modelStatus.textContent = `Embedding model "${embeddingModelName}" loaded!`;
                showMessage("Embedding model loaded successfully!", 'success');
            } catch (error) {
                console.error("Error loading embedding model:", error);
                modelStatus.textContent = `Error loading model: ${error.message}`;
                showMessage(`Failed to load embedding model: ${error.message}`, 'error');
            } finally {
                saveChunkButton.disabled = false;
                generateEmbeddingsButton.disabled = false;
                searchChunksButton.disabled = false;
                loadCsvButton.disabled = false;
                downloadCsvButton.disabled = false;
                createNewDbButton.disabled = false;
                deleteCurrentDbButton.disabled = false;
                loadDbButton.disabled = false;
            }
        }

        // Generate embeddings for all non-embedded chunks
        async function generateEmbeddingsForChunks() {
            if (!embeddingPipeline) {
                showMessage("Embedding model not loaded. Please wait.", 'info');
                return;
            }
            if (!db) {
                showMessage("No database loaded. Please create or load a database first.", 'error');
                return;
            }

            generateEmbeddingsButton.disabled = true;
            saveChunkButton.disabled = true;
            searchChunksButton.disabled = true;
            loadCsvButton.disabled = true;
            downloadCsvButton.disabled = true;
            createNewDbButton.disabled = true;
            deleteCurrentDbButton.disabled = true;
            loadDbButton.disabled = true;
            modelStatus.textContent = "Generating embeddings for new chunks...";

            try {
                const transaction = db.transaction([STORE_NAME], 'readwrite');
                const objectStore = transaction.objectStore(STORE_NAME);
                const allItemsRequest = objectStore.getAll();

                allItemsRequest.onsuccess = async (event) => {
                    const allItems = event.target.result;
                    const chunksToEmbed = allItems.filter(item => item.id !== COUNTER_KEY && !item.isEmbedded);

                    if (chunksToEmbed.length === 0) {
                        showMessage("No new chunks to embed.", 'info');
                        modelStatus.textContent = `Embedding model "${embeddingModelName}" loaded!`;
                        generateEmbeddingsButton.disabled = false;
                        saveChunkButton.disabled = false;
                        searchChunksButton.disabled = false;
                        loadCsvButton.disabled = false;
                        downloadCsvButton.disabled = false;
                        createNewDbButton.disabled = false;
                        deleteCurrentDbButton.disabled = false;
                        loadDbButton.disabled = false;
                        return;
                    }

                    showMessage(`Generating embeddings for ${chunksToEmbed.length} chunks... This might take a while.`, 'info');

                    for (const chunk of chunksToEmbed) {
                        try {
                            const output = await embeddingPipeline(chunk.content, { pooling: 'mean', normalize: true });
                            const embeddingArray = Array.from(output.data);

                            chunk.embedding = embeddingArray;
                            chunk.embeddingModel = embeddingModelName;
                            chunk.isEmbedded = true;

                            objectStore.put(chunk);
                            console.log(`Embedded chunk ${chunk.id}`);
                        } catch (embedError) {
                            console.error(`Error embedding chunk ${chunk.id}:`, embedError);
                            showMessage(`Failed to embed chunk ${chunk.id}: ${embedError.message}`, 'error');
                            chunk.isEmbedded = false;
                            objectStore.put(chunk);
                        }
                    }

                    transaction.oncomplete = () => {
                        showMessage("All pending chunks processed for embedding!", 'success');
                        modelStatus.textContent = `Embedding model "${embeddingModelName}" loaded!`;
                        displayChunks();
                        updateStats();
                        generateEmbeddingsButton.disabled = false;
                        saveChunkButton.disabled = false;
                        searchChunksButton.disabled = false;
                        loadCsvButton.disabled = false;
                        downloadCsvButton.disabled = false;
                        createNewDbButton.disabled = false;
                        deleteCurrentDbButton.disabled = false;
                        loadDbButton.disabled = false;
                    };

                    transaction.onerror = (event) => {
                        console.error("Embedding transaction error:", event.target.error);
                        showMessage("Error during embedding process: " + event.target.error?.message, 'error');
                        generateEmbeddingsButton.disabled = false;
                        saveChunkButton.disabled = false;
                        searchChunksButton.disabled = false;
                        loadCsvButton.disabled = false;
                        downloadCsvButton.disabled = false;
                        createNewDbButton.disabled = false;
                        deleteCurrentDbButton.disabled = false;
                        loadDbButton.disabled = false;
                    };
                };

                allItemsRequest.onerror = (event) => {
                    console.error("Error retrieving chunks for embedding:", event.target.error);
                    showMessage("Error retrieving chunks for embedding: " + event.target.error?.message, 'error');
                    generateEmbeddingsButton.disabled = false;
                    saveChunkButton.disabled = false;
                    searchChunksButton.disabled = false;
                    loadCsvButton.disabled = false;
                    downloadCsvButton.disabled = false;
                    createNewDbButton.disabled = false;
                    deleteCurrentDbButton.disabled = false;
                    loadDbButton.disabled = false;
                };

            } catch (error) {
                console.error("Failed to generate embeddings:", error);
                showMessage("Failed to generate embeddings due to database or model error.", 'error');
            } finally {
                generateEmbeddingsButton.disabled = false;
                saveChunkButton.disabled = false;
                searchChunksButton.disabled = false;
                loadCsvButton.disabled = false;
                downloadCsvButton.disabled = false;
                createNewDbButton.disabled = false;
                deleteCurrentDbButton.disabled = false;
                loadDbButton.disabled = false;
            }
        }

        // --- Vector Similarity Search Functions ---
        function cosineSimilarity(vecA, vecB) {
            if (!vecA || !vecB || vecA.length !== vecB.length) {
                return 0;
            }
            let dotProduct = 0;
            let magnitudeA = 0;
            let magnitudeB = 0;
            for (let i = 0; i < vecA.length; i++) {
                dotProduct += vecA[i] * vecB[i];
                magnitudeA += vecA[i] * vecA[i];
                magnitudeB += vecB[i] * vecB[i];
            }
            magnitudeA = Math.sqrt(magnitudeA);
            magnitudeB = Math.sqrt(magnitudeB);
            if (magnitudeA === 0 || magnitudeB === 0) {
                return 0;
            }
            return dotProduct / (magnitudeA * magnitudeB);
        }

        async function searchRelevantChunks() {
            const queryText = queryInput.value.trim();
            const topN = parseInt(topResponsesInput.value, 10); // Get user-defined topN
            if (isNaN(topN) || topN < 1) {
                showMessage("Please enter a valid number (1 or more) for 'Number of Top Responses'.", 'info');
                return;
            }

            if (queryText === "") {
                showMessage("Please enter a query to search.", 'info');
                return;
            }
            if (!embeddingPipeline) {
                showMessage("Embedding model not loaded. Cannot perform search.", 'error');
                return;
            }
            if (!db) {
                showMessage("No database loaded. Please create or load a database first.", 'error');
                return;
            }

            searchChunksButton.disabled = true;
            modelStatus.textContent = "Generating query embedding and searching...";
            searchResultsArea.innerHTML = '<p>Searching...</p>';
            llmPromptGroup.style.display = 'none';
            llmPromptOutput.value = '';
            llmJsonPromptGroup.style.display = 'none';
            llmJsonPromptOutput.value = '';

            try {
                const queryOutput = await embeddingPipeline(queryText, { pooling: 'mean', normalize: true });
                const queryEmbedding = Array.from(queryOutput.data);

                const transaction = db.transaction([STORE_NAME], 'readonly');
                const objectStore = transaction.objectStore(STORE_NAME);
                const allItemsRequest = objectStore.getAll();

                allItemsRequest.onsuccess = (event) => {
                    const allItems = event.target.result;
                    const embeddedChunks = allItems.filter(item => item.id !== COUNTER_KEY && item.isEmbedded && item.embedding);

                    if (embeddedChunks.length === 0) {
                        searchResultsArea.innerHTML = '<p>No embedded chunks available to search.</p>';
                        showMessage("No embedded chunks found. Please add text and generate embeddings first.", 'info');
                        modelStatus.textContent = `Embedding model "${embeddingModelName}" loaded!`;
                        searchChunksButton.disabled = false;
                        return;
                    }

                    const rankedResults = [];
                    for (const chunk of embeddedChunks) {
                        const similarity = cosineSimilarity(queryEmbedding, chunk.embedding);
                        rankedResults.push({ chunk: chunk, similarity: similarity });
                    }

                    rankedResults.sort((a, b) => b.similarity - a.similarity);

                    searchResultsArea.innerHTML = '<h3>Top Relevant Chunks:</h3>';
                    let promptContextPlain = [];
                    let promptContextJson = [];
                    let relevantChunksDisplayed = 0; // Tracks chunks displayed, up to topN

                    if (rankedResults.length > 0) {
                        const resultsList = document.createElement('div');
                        for (const result of rankedResults) {
                            if (relevantChunksDisplayed >= topN) break; // Limit based on user's topN input
                            if (result.similarity > 0) { // Only show chunks with positive similarity
                                const resultDiv = document.createElement('div');
                                resultDiv.style.cssText = 'background-color: #dbeafe; padding: 15px; border-radius: 4px; margin-bottom: 10px; word-wrap: break-word; border-left: 4px solid #3b82f6;'; /* inline styles */
                                resultDiv.innerHTML = `
                                    <p><strong style="color: #1e40af;">Similarity:</strong> ${(result.similarity * 100).toFixed(2)}%</p>
                                    <p><strong>Source:</strong> ${result.chunk.source}</p>
                                    <p><strong>Content:</strong> ${result.chunk.content.length > 200 ? result.chunk.content.substring(0, 200) + '...' : result.chunk.content}</p>
                                `;
                                resultsList.appendChild(resultDiv);
                                promptContextPlain.push(`Chunk ${relevantChunksDisplayed + 1} (Source: ${result.chunk.source}): ${result.chunk.content}`);
                                promptContextJson.push({
                                    id: result.chunk.id,
                                    source: result.chunk.source,
                                    content: result.chunk.content,
                                    similarity: result.similarity
                                });
                                relevantChunksDisplayed++;
                            }
                        }
                        if (relevantChunksDisplayed === 0) {
                             searchResultsArea.innerHTML = '<p>No relevant chunks found for this query (similarity too low).</p>';
                        } else {
                            searchResultsArea.appendChild(resultsList);

                            const llmPrompt = `Based on the following information, answer the question:\n\nInformation:\n${promptContextPlain.join('\n\n')}\n\nQuestion: ${queryText}\n\nAnswer:`;
                            llmPromptOutput.value = llmPrompt;
                            llmPromptGroup.style.display = 'block';

                            const llmJsonPrompt = {
                                query: queryText,
                                context: promptContextJson,
                                format_instructions: "Please answer based on the provided context."
                            };
                            llmJsonPromptOutput.value = JSON.stringify(llmJsonPrompt, null, 2);
                            llmJsonPromptGroup.style.display = 'block';
                        }

                    } else {
                        searchResultsArea.innerHTML = '<p>No relevant chunks found.</p>';
                    }

                    showMessage("Search complete!", 'success');
                    modelStatus.textContent = `Embedding model "${embeddingModelName}" loaded!`;

                };

                allItemsRequest.onerror = (event) => {
                    console.error("Error retrieving chunks for search:", event.target.error);
                    showMessage("Error retrieving chunks for search: " + event.target.error?.message, 'error');
                };

            } catch (error) {
                console.error("Failed to perform search:", error);
                showMessage("Failed to perform search due to model or database error.", 'error');
            } finally {
                searchChunksButton.disabled = false;
            }
        }

        // Function to copy LLM prompt (plain text) to clipboard
        function copyPromptToClipboard() {
            llmPromptOutput.select();
            llmPromptOutput.setSelectionRange(0, 99999);
            try {
                document.execCommand('copy');
                showMessage('Plain text prompt copied to clipboard!', 'success');
            } catch (err) {
                console.error('Failed to copy prompt: ', err);
                showMessage('Failed to copy prompt.', 'error');
            }
        }

        // Function to copy LLM prompt (JSON) to clipboard
        function copyJsonPromptToClipboard() {
            llmJsonPromptOutput.select();
            llmJsonPromptOutput.setSelectionRange(0, 99999);
            try {
                document.execCommand('copy');
                showMessage('JSON prompt copied to clipboard!', 'success');
            } catch (err) {
                console.error('Failed to copy JSON prompt: ', err);
                showMessage('Failed to copy JSON prompt.', 'error');
            }
        }

        // --- CSV Input/Output Functions ---

        /**
         * Parses a single CSV line, handling quoted fields and escaped quotes.
         * This uses a state-machine approach for robustness.
         * @param {string} line The CSV line to parse.
         * @returns {Array<string>} An array of parsed fields.
         */
        function parseCsvLine(line) {
            const result = [];
            let inQuote = false;
            let currentField = '';
            for (let i = 0; i < line.length; i++) {
                const char = line[i];
                if (char === '"') {
                    // Handle escaped double quote: "" becomes "
                    if (inQuote && i + 1 < line.length && line[i + 1] === '"') {
                        currentField += '"';
                        i++; // Skip the next character as it's part of the escaped quote
                    } else {
                        // Toggle inQuote state
                        inQuote = !inQuote;
                    }
                } else if (char === ',' && !inQuote) {
                    // End of an unquoted field or a quoted field that just closed
                    result.push(currentField);
                    currentField = '';
                } else {
                    // Add character to current field
                    currentField += char;
                }
            }
            // Add the last field (after the last comma or if no commas)
            result.push(currentField);

            return result;
        }

        async function loadCsvData() {
            const file = csvFileInput.files[0];
            if (!file) {
                showMessage("Please select a CSV file.", 'info');
                return;
            }
            if (!db) {
                showMessage("No database loaded. Please create or load a database first to import CSV.", 'error');
                return;
            }

            const reader = new FileReader();
            reader.onload = async (e) => {
                const csvText = e.target.result;
                const lines = csvText.split(/\r?\n/); // Use regex to handle both \n and \r\n line endings
                let successfulImports = 0;
                let failedImports = 0;

                // Parse header using the new robust function
                const header = parseCsvLine(lines[0] || '').map(h => h.trim().toLowerCase());
                const contentIndex = header.indexOf('content');
                const sourceIndex = header.indexOf('source');

                if (contentIndex === -1 || sourceIndex === -1) {
                    showMessage("CSV must contain 'content' and 'source' columns.", 'error');
                    return;
                }

                const chunksToSave = [];
                // Changed minimum content length from 10 to 1 to allow shorter but meaningful entries
                const MIN_MEANINGFUL_CONTENT_LENGTH = 1; 

                for (let i = 1; i < lines.length; i++) {
                    const line = lines[i].trim();
                    if (line === '') continue; // Skip empty lines

                    const parts = parseCsvLine(line); // Use the new parsing function

                    // Ensure indices are within bounds for content and source columns
                    if (contentIndex < parts.length && sourceIndex < parts.length) {
                        let content = parts[contentIndex]?.trim() || ''; // Get content, default to empty string
                        let source = parts[sourceIndex]?.trim() || 'CSV Import';

                        // Remove common control characters that might interfere or be unwanted
                        // This pattern only removes ASCII control characters (0x00-0x1F and 0x7F)
                        content = content.replace(/[\x00-\x1F\x7F]/g, '').trim();

                        // Filter out empty or extremely short/meaningless content after cleaning
                        if (content.length >= MIN_MEANINGFUL_CONTENT_LENGTH) {
                            chunksToSave.push({ content, source });
                        } else {
                            failedImports++;
                            console.warn(`Skipping CSV row (content too short or contains only control characters after cleaning, length ${content.length}): "${line}"`);
                        }
                    } else {
                        failedImports++;
                        console.warn("Skipping malformed CSV row (not enough columns for 'content' or 'source'):", line);
                    }
                }

                if (chunksToSave.length === 0 && failedImports === 0) {
                    showMessage("No valid data found in CSV to import.", 'info');
                    return;
                }

                // Disable buttons during processing
                loadCsvButton.disabled = true;
                saveChunkButton.disabled = true;
                generateEmbeddingsButton.disabled = true;
                downloadCsvButton.disabled = true;

                showMessage(`Importing ${chunksToSave.length} chunks from CSV...`);

                try {
                    const transaction = db.transaction([STORE_NAME], 'readwrite');
                    const objectStore = transaction.objectStore(STORE_NAME);

                    const counterRequest = objectStore.get(COUNTER_KEY);
                    counterRequest.onsuccess = () => {
                        let nextIdValue = counterRequest.result ? counterRequest.result.value : 1;

                        chunksToSave.forEach(chunkData => {
                            const chunkSize = parseInt(document.getElementById('chunkSizeInput').value, 10);
                            const autoChunk = document.getElementById('autoChunkCheckbox').checked;

                            let currentLineChunks = [];
                            if (autoChunk && chunkData.content.length > chunkSize) {
                                currentLineChunks = splitTextIntoChunks(chunkData.content, chunkSize, chunkData.source);
                            } else {
                                // If not auto-chunking or if content is smaller than chunk size, treat as a single chunk
                                currentLineChunks.push(chunkData);
                            }

                            currentLineChunks.forEach(chunk => {
                                const chunkId = 'chunk_' + nextIdValue;
                                const textChunk = {
                                    id: chunkId,
                                    content: chunk.content,
                                    source: chunk.source,
                                    timestamp: new Date().toISOString(),
                                    wordCount: chunk.content.split(/\s+/).length,
                                    charCount: chunk.content.length,
                                    embedding: null,
                                    embeddingModel: null,
                                    isEmbedded: false
                                };
                                try {
                                    objectStore.put(textChunk);
                                    nextIdValue++;
                                    successfulImports++;
                                    console.log(`DEBUG: Added chunk ${chunkId} from CSV to transaction.`);
                                } catch (e) {
                                    console.error(`DEBUG: Failed to add chunk ${chunkId} from CSV to transaction:`, e);
                                    failedImports++; // Increment failed count for DB errors as well
                                }
                            });
                        });
                        // Update counter at the end of the batch
                        objectStore.put({ id: COUNTER_KEY, value: nextIdValue });
                    };
                    counterRequest.onerror = (event) => {
                        console.error("Counter request error during CSV import preparation:", event.target.error);
                        showMessage(`Error preparing CSV import: ${event.target.error?.message}`, 'error');
                        // No need to adjust failedImports here, as it's already accounted for in the loop or will be caught by transaction error
                    };

                    transaction.oncomplete = () => {
                        showMessage(`CSV import complete. Successfully added: ${successfulImports} chunks. Failed: ${failedImports}.`, 'success');
                        displayChunks();
                        updateStats();
                        // Re-enable buttons
                        loadCsvButton.disabled = false;
                        saveChunkButton.disabled = false;
                        generateEmbeddingsButton.disabled = false;
                        downloadCsvButton.disabled = false;
                    };
                    transaction.onerror = (event) => {
                        console.error("Error during CSV import transaction:", event.target.error);
                        showMessage(`Error during CSV import: ${event.target.error?.message}. Successfully added: ${successfulImports} chunks. Failed: ${chunksToSave.length - successfulImports}.`, 'error');
                        // Re-enable buttons
                        loadCsvButton.disabled = false;
                        saveChunkButton.disabled = false;
                        generateEmbeddingsButton.disabled = false;
                        downloadCsvButton.disabled = false;
                    };

                } catch (error) {
                    console.error("Failed to initiate CSV import transaction:", error);
                    showMessage(`Failed to load CSV: ${error.message || error}`, 'error');
                    // Re-enable buttons
                    loadCsvButton.disabled = false;
                    saveChunkButton.disabled = false;
                    generateEmbeddingsButton.disabled = false;
                    downloadCsvButton.disabled = false;
                }
            };
            reader.onerror = () => {
                showMessage("Error reading CSV file.", 'error');
                loadCsvButton.disabled = false;
                saveChunkButton.disabled = false;
                generateEmbeddingsButton.disabled = false;
                downloadCsvButton.disabled = false;
            };
            reader.readAsText(file);
        }

        async function downloadCsvData() {
            try {
                if (!db) {
                    showMessage("No database loaded to download from.", 'info');
                    return;
                }

                const transaction = db.transaction([STORE_NAME], 'readonly');
                const objectStore = transaction.objectStore(STORE_NAME);
                const allItemsRequest = objectStore.getAll();

                allItemsRequest.onsuccess = (event) => {
                    const allItems = event.target.result;
                    const chunks = allItems.filter(item => item.id !== COUNTER_KEY);

                    if (chunks.length === 0) {
                        showMessage("No data to download.", 'info');
                        return;
                    }

                    let csvContent = "number,content,source\n";

                    chunks.forEach(chunk => {
                        const number = chunk.id.split('_')[1];
                        // Escape quotes by doubling them, then wrap in quotes
                        const escapedContent = `"${chunk.content.replace(/"/g, '""')}"`;
                        const escapedSource = `"${chunk.source.replace(/"/g, '""')}"`;
                        csvContent += `${number},${escapedContent},${escapedSource}\n`;
                    });

                    const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
                    const link = document.createElement('a');
                    link.href = URL.createObjectURL(blob);
                    link.download = `${currentDBName}_data.csv`; // Use current DB name in filename
                    document.body.appendChild(link);
                    link.click();
                    document.body.removeChild(link);
                    URL.revokeObjectURL(link.href);
                    showMessage("Data downloaded as CSV!", 'success');
                };

                allItemsRequest.onerror = (event) => {
                    console.error("Error fetching data for CSV download:", event.target.error);
                    showMessage("Error fetching data for CSV download.", 'error');
                };

            } catch (error) {
                console.error("Failed to download CSV:", error);
                showMessage("Failed to download CSV due to database error.", 'error');
            }
        }

        // --- Database Management Functions ---

        // Gets list of RAG databases stored in localStorage
        function getRAGDBList() {
            const dbListString = localStorage.getItem(DB_LIST_KEY);
            return dbListString ? JSON.parse(dbListString) : [];
        }

        // Saves updated list of RAG databases to localStorage
        function saveRAGDBList(dbList) {
            localStorage.setItem(DB_LIST_KEY, JSON.stringify(dbList));
        }

        // Populates the database selector dropdown
        function populateDbSelector() {
            dbSelector.innerHTML = ''; // Clear existing options
            const dbList = getRAGDBList();
            if (dbList.length === 0) {
                const option = document.createElement('option');
                option.value = '';
                option.textContent = 'No databases found';
                dbSelector.appendChild(option);
                loadDbButton.disabled = true;
                deleteCurrentDbButton.disabled = true;
                return;
            }

            dbList.forEach(dbName => {
                const option = document.createElement('option');
                option.value = dbName;
                option.textContent = dbName;
                dbSelector.appendChild(option);
            });

            // Set selected option to currentDBName if it exists
            if (currentDBName && dbList.includes(currentDBName)) {
                dbSelector.value = currentDBName;
            } else if (dbList.length > 0) {
                dbSelector.value = dbList[0]; // Select the first one if no currentDBName
            }
            loadDbButton.disabled = false;
            deleteCurrentDbButton.disabled = false;
        }

        // Handles loading a selected database
        async function loadSelectedDatabase() {
            const selectedDbName = dbSelector.value;
            if (selectedDbName && selectedDbName !== currentDBName) {
                try {
                    await openDB(selectedDbName);
                    displayChunks();
                    updateStats();
                }
                catch (error) {
                    console.error("Error loading selected database:", error);
                }
            } else if (selectedDbName === currentDBName) {
                showMessage(`Database '${selectedDbName}' is already loaded.`, 'info');
            } else {
                showMessage("Please select a database to load.", 'info');
            }
        }

        // Handles creating a new database
        async function createNewDatabase() {
            const newName = newDbNameInput.value.trim();
            if (!newName) {
                showMessage("Please enter a name for the new database.", 'info');
                return;
            }
            if (getRAGDBList().includes(newName)) {
                showMessage(`Database '${newName}' already exists. Please choose a different name or load it.`, 'info');
                return;
            }

            try {
                await openDB(newName);
                let dbList = getRAGDBList();
                dbList.push(newName);
                saveRAGDBList(dbList);
                populateDbSelector();
                newDbNameInput.value = ''; // Clear input
                showMessage(`Database '${newName}' created and loaded!`, 'success');
                displayChunks(); // Refresh display for new empty DB
                updateStats();
            } catch (error) {
                console.error("Error creating new database:", error);
                showMessage(`Failed to create database '${newName}'.`, 'error');
            }
        }

        // Handles deleting the current database
        async function deleteCurrentDatabase() {
            if (!currentDBName) {
                showMessage("No database is currently loaded to delete.", 'info');
                return;
            }

            // Using custom message box instead of window.confirm
            const confirmDelete = await new Promise(resolve => {
                const userConfirmed = window.confirm(`Are you sure you want to delete the database '${currentDBName}'? This action cannot be undone.`);
                resolve(userConfirmed);
            });

            if (!confirmDelete) {
                return;
            }

            try {
                if (db) {
                    db.close(); // Close the connection before deleting
                    db = null;
                }

                const request = indexedDB.deleteDatabase(currentDBName);
                request.onsuccess = () => {
                    console.log(`Database '${currentDBName}' deleted successfully.`);
                    showMessage(`Database '${currentDBName}' deleted!`, 'success');

                    let dbList = getRAGDBList();
                    dbList = dbList.filter(name => name !== currentDBName);
                    saveRAGDBList(dbList);

                    currentDBName = null;
                    localStorage.removeItem(LAST_USED_DB_KEY);
                    currentDbNameDisplay.textContent = 'N/A';
                    populateDbSelector(); // Re-populate dropdown

                    // Attempt to load the first available DB or initialize a default one
                    if (dbList.length > 0) {
                        loadSelectedDatabase(); // Loads the first one in the list
                    } else {
                        // If no DBs left, initialize a default one for the user
                        const defaultDb = 'default_rag_db';
                        newDbNameInput.value = defaultDb; // Pre-fill for convenience
                        createNewDatabase(); // Creates and loads the default DB
                    }
                    displayChunks(); // Refresh display
                    updateStats();
                };
                request.onerror = (event) => {
                    console.error("Error deleting database:", event.target.error);
                    showMessage(`Failed to delete database '${currentDBName}': ${event.target.error?.message}`, 'error');
                };
            } catch (error) {
                console.error("Error initiating database deletion:", error);
                showMessage("Failed to initiate database deletion.", 'error');
            }
        }


        // Add event listeners
        generateEmbeddingsButton.addEventListener('click', generateEmbeddingsForChunks);
        searchChunksButton.addEventListener('click', searchRelevantChunks);
        copyPromptButton.addEventListener('click', copyPromptToClipboard);
        copyJsonPromptButton.addEventListener('click', copyJsonPromptToClipboard);
        loadCsvButton.addEventListener('click', loadCsvData);
        downloadCsvButton.addEventListener('click', downloadCsvData);

        // New DB management event listeners
        dbSelector.addEventListener('change', loadSelectedDatabase);
        loadDbButton.addEventListener('click', loadSelectedDatabase);
        createNewDbButton.addEventListener('click', createNewDatabase);
        deleteCurrentDbButton.addEventListener('click', deleteCurrentDatabase);

        // New show chunks checkbox event listener
        showChunksCheckbox.addEventListener('change', displayChunks);


        // Initialize when page loads
        window.onload = async () => {
            console.log("DEBUG: window.onload event fired. Starting initialization."); // New log
            try {
                // First, populate the selector
                populateDbSelector();

                let lastUsedDb = localStorage.getItem(LAST_USED_DB_KEY);
                const existingDbList = getRAGDBList();

                if (!lastUsedDb && existingDbList.length > 0) {
                    // If no last used, but existing DBs, load the first one
                    lastUsedDb = existingDbList[0];
                } else if (!lastUsedDb && existingDbList.length === 0) {
                    // If no last used and no existing DBs, suggest creating a default one
                    lastUsedDb = 'default_rag_db';
                    newDbNameInput.value = lastUsedDb; // Pre-fill
                    showMessage("No RAG database found. A 'default_rag_db' has been suggested. Click 'Create New DB' to start.", 'info');
                    // Don't auto-create, let the user click "Create New DB"
                    currentDbNameDisplay.textContent = 'N/A (pending)';
                    console.log("DEBUG: No DB found, suggesting default and returning from onload."); // New log
                    return; // Exit onload, as user interaction is needed
                }

                if (lastUsedDb) {
                    console.log(`DEBUG: Attempting to open DB: ${lastUsedDb}`); // New log
                    await openDB(lastUsedDb);
                    console.log("DEBUG: DB opened, initializing model."); // New log
                    await initializeModel(); // Load the embedding model after DB is ready
                    console.log("DEBUG: Model initialized, displaying chunks."); // New log
                    displayChunks(); // Call displayChunks here to set initial visibility
                    updateStats();
                    console.log("DEBUG: Initialization complete."); // New log
                } else {
                    // Fallback if somehow still no DB name after checks
                    showMessage("Please create a new RAG database to begin.", 'info');
                    currentDbNameDisplay.textContent = 'N/A';
                    console.log("DEBUG: Fallback: No DB name, prompting user to create."); // New log
                }
            } catch (error) {
                console.error("DEBUG: Fatal initialization error in window.onload:", error); // More specific error logging
                showMessage(`A critical error occurred during initialization: ${error.message || error}`, 'error');
                currentDbNameDisplay.textContent = 'N/A';
                localStorage.removeItem(LAST_USED_DB_KEY); // Clear invalid last used
                populateDbSelector(); // Re-populate in case something changed
            }
            console.log("DEBUG: End of window.onload event handler."); // New log
        };
    </script>
</body>
</html>
